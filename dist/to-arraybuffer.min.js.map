{"version":3,"sources":["core/index.js","dist.js"],"names":["toArrayBuffer","target","Promise","ReferenceError","ArrayBuffer","reject","Error","constructor","resolve","Blob","String","el","document","querySelector","HTMLInputElement","files","FileList","length","File","FileReader","TypeError","reader","onloadend","ev","result","onerror","error","readAsArrayBuffer","module","exports","window","require"],"mappings":";AAOA,IAAMA,EAAgB,SAACC,GAEjB,GAAmB,oBAAZC,QACH,MAAA,IAAIC,eAAe,+CACpB,GAA2B,oBAAhBC,YACV,MAAA,IAAID,eAAe,kDAGvB,IAACF,EAEIC,OAAAA,QAAQG,OAAO,IAAIC,MAA+DL,yDAAAA,OAAAA,EAAlF,SAGLA,GAAAA,EAAOM,cAAgBH,YAClBF,OAAAA,QAAQM,QAAQP,GAGrB,GAAgB,oBAATQ,MAAwBR,EAAOM,cAAgBE,KACjDR,OAAAA,EAAOD,gBAGZC,GAAAA,EAAOM,cAAgBG,OAAQ,CAC3BC,IAAAA,EAAKC,SAASC,cAAcZ,GAC9B,IAACU,EAEIT,OAAAA,QAAQG,OAAO,IAAIC,MAAsCL,gCAAAA,OAAAA,EAAzD,QAETA,EAASU,EAGP,GAA4B,oBAArBG,kBAAoCb,EAAOM,cAAgBO,iBAAkB,CAClF,IAACb,EAAOc,MAEHb,OAAAA,QAAQG,OAAO,IAAIC,MAAM,wDAElCL,EAASA,EAAOc,MAGd,GAAoB,oBAAbC,UAA4Bf,EAAOM,cAAgBS,SAAU,CAClEf,GAAkB,IAAlBA,EAAOgB,OAEFf,OAAAA,QAAQG,OAAO,IAAIC,MAAM,8BAElCL,EAASA,EAAO,GAGd,GAAgB,oBAATiB,MAAwBjB,EAAOM,cAAgBW,KAAM,CAC1D,GAAsB,oBAAfC,WACH,MAAA,IAAIC,UAAU,iDAEhBC,IAAAA,EAAS,IAAIF,WACZ,OAAA,IAAIjB,QAAQ,SAACM,EAASH,GAC3BgB,EAAOC,UAAY,SAACC,GAAOf,OAAAA,EAAQe,EAAGtB,OAAOuB,SAC7CH,EAAOI,QAAU,SAACF,GAAOlB,OAAAA,EAAOkB,EAAGtB,OAAOyB,QAC1CL,EAAOM,kBAAkB1B,KAKtBC,OAAAA,QAAQG,OAAO,IAAIC,MAAM,0HAGlCsB,OAAOC,QAAU7B;;ACrEjB8B,OAAO9B,cAAgB+B,QAAQ","file":"to-arraybuffer.min.js","sourceRoot":"..\\src","sourcesContent":["\n/**\n * Generate the Array Buffer object for target reference provided as parameter.\n *\n * @param {String|HTMLElement|FileList|File|ArrayBuffer|Blob} target\n * @return {Promise<ArrayBuffer>}\n */\nconst toArrayBuffer = (target) => {\n\n  if (typeof Promise === 'undefined') {\n    throw new ReferenceError('Your environment does not support Promises.')\n  } else if (typeof ArrayBuffer === 'undefined') {\n    throw new ReferenceError('Your environment does not support ArrayBuffer.')\n  }\n\n  if (!target) {\n    // eslint-disable-next-line max-len\n    return Promise.reject(new Error(`Parameter to convert to ArrayBuffer is empty (value: '${target}').`))\n  }\n\n  if (target.constructor === ArrayBuffer) {\n    return Promise.resolve(target)\n  }\n\n  if (typeof Blob !== 'undefined' && target.constructor === Blob) {\n    return target.toArrayBuffer()\n  }\n\n  if (target.constructor === String) {\n    const el = document.querySelector(target)\n    if (!el) {\n      // eslint-disable-next-line max-len\n      return Promise.reject(new Error(`No HTML found with selector \"${target}\".`))\n    }\n    target = el\n  }\n\n  if (typeof HTMLInputElement !== 'undefined' && target.constructor === HTMLInputElement) {\n    if (!target.files) {\n      // eslint-disable-next-line max-len\n      return Promise.reject(new Error('HTML input element reference is not of type \"file\".'))\n    }\n    target = target.files\n  }\n\n  if (typeof FileList !== 'undefined' && target.constructor === FileList) {\n    if (target.length === 0) {\n      // eslint-disable-next-line max-len\n      return Promise.reject(new Error('Object FileList is empty.'))\n    }\n    target = target[0]\n  }\n\n  if (typeof File !== 'undefined' && target.constructor === File) {\n    if (typeof FileReader === 'undefined') {\n      throw new TypeError('Your environment does not support FileReader.')\n    }\n    const reader = new FileReader()\n    return new Promise((resolve, reject) => {\n      reader.onloadend = (ev) => resolve(ev.target.result)\n      reader.onerror = (ev) => reject(ev.target.error)\n      reader.readAsArrayBuffer(target)\n    })\n  }\n\n  // eslint-disable-next-line max-len\n  return Promise.reject(new Error('Parameter type must be an instance of HTMLInputElement, FileList, File, String (input selector), Blob or ArrayBuffer'))\n}\n\nmodule.exports = toArrayBuffer\n","window.toArrayBuffer = require('./core')\n"]}